
\documentclass [12pt , a4paper] {article}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{xfrac}
\usepackage{graphicx}      % include this line if your document contains figures
%\usepackage{natbib}        % required for bibliography
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{amssymb}%
\usepackage{color}


%===============================================================================
\begin{document}

\lstset{language= Matlab , basicstyle=\small \ttfamily, stringstyle=\color{magenta},  commentstyle=\color{green}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus .5ex minus 0.2ex}
\linespread{1.5}

\input{./title.tex}

%===============================================================================

\section{Introduction}
The Robust Controller Design Toolbox is a tool for designing robust linearly parameterized controllers. It can be used to design linearly parameterized controllers of any order for parametric models or nonparametric models obtained for example by the identification toolbox of MATLAB. The robust controllers are designed in terms of $H_\infty$ performance or classical robustness margins such as the gain and phase margin, for single/multi-model, SISO/MIMO systems. In all of design cases, linear or convex optimization problems are solved. For SISO systems the well-known \texttt{linprog} or \texttt{quadprog} (depending on the problem) solvers are used when in MIMO models whenever dealing with stability conditions other standard solvers such as \texttt{sdpt3} are used. In these cases, the YALMIP package \cite{YALMIP} is used for optimization. The toolbox also supports designing gain-scheduled controllers, say in Linear Parameter Varying (LPV) systems. 

In this manual as well as describing theoretical bases of the optimization problems in a turse manner, our main attempt is to provide a quite comprehensive set of examples to exhibit wide functionality, yet user-friendlyness of this tool.   

\section{Background theory}
In this section, the theoretical bases of the design methods of the toolbox are presented. That the toolbox solves what kind of optimization problems, i.e. what kind of objective functions and constranits, in different cases of the desired performances (GPC, loop shaping, and $H_{\infty}$), is the main subject of this section. Also how these methods are applied in MIMO systems and gain-cheduled controller design, is descriped. In the sequel, first the class of controllers and models are presented and then different control performances that can be considered by the toolbox are given.

\subsection{Class of models and controllers}
\textcolor{blue}{\textbf{Models}}

Models can be parametric or nonparametric. The design method, in fact, needs the frequency response of the plant model in a finite number of frequencies which can be obtained directly from data by spectral analysis (for example by the identification toolbox of Matlab) or computed from a parametric model. Therefore, high order models with pure time delay and non minimum phase zeros can be considered with no approximation. Thus, we would have the set of models:  $\textsl{M}=\{G_i(j\omega), \: i=1,\ldots,m \}$ where $G_i(j\omega)$ can be a scalar or a matrix representing the frequency response of a SISO or MIMO model, respectively, over a vector of frequency points $\omega_i=[\omega_{i_1}, \omega_{i_2}, \ldots, \omega_{i_{N_i}}]$. $N_i$ is large enough to give a good approximation of the frequency response of the system $G_i$. The methods are described on a SISO stystem. It will also be explained how these methods can be applied in designing multivariable decoupling controllers for MIMO systems.  

\textcolor{blue}{\textbf{Controllers}}

The toollbox designs linearly parameterized controollers. A linearly parameterized controller has this form:
\begin{equation}
\label{linparcon}
\rho^T \phi(s)=[\rho_1 \: \: \rho_2 \: \: \ldots \:\: \rho_n]\times [\phi_1(s) \: \: \phi_2(s) \:\: \ldots \:\: \phi_n(s)]^T
\end{equation}
where $\rho_1$, $\rho_2$, $\ldots$, $\rho_n$ are controller parameters and $\phi_1(s)$, $\phi_2(s)$, $\ldots$, $\phi_n(s)$ are basis transfer functions. These transfer functions must be stable, i.e. with no right half plane poles. 

\textcolor{magenta}{\textbf{PID, PI, PD:}}

The proportional-integral-derivative (PID) controller is a familiar case of these types of controllers with 3 parameters $[\rho_1 \:\, \rho_2 \:\, \rho_3]=[k_p \:\, k_i \:\, k_d]$ and the vector of basis transfer functions:
\begin{equation}
\phi (s)=[1 \:\: \frac{1}{s} \:\: \frac{s}{1+\tau s}]^T \quad \mbox{(for continuous systems)}
\end{equation}
or:
\begin{equation}
\phi (z)=[1 \:\: \frac{z}{z-1} \:\: \frac{z-1}{z}]^T \quad \mbox{(for discrete-time systems)}
\end{equation}
where $\tau$ is the time constant of the derivative part in the continuous one. PI and PD are special cases of the above equations. Besides these common linearly parameterized controllers, this toolbox supports the following higher order types, too: 

\textcolor{magenta}{\textbf{Laguerre basis functions:}}

\begin{equation}
\phi_1(s)=1, \quad \phi_i(s)=\frac{\sqrt{2\xi}(s-\xi)^{i-2}}{(s+\xi)^{i-1}} \quad   i=2,3,\ldots,n+1 \quad \mbox{(for continuous systems)}
\end{equation}
or:
\begin{equation}
\phi_1(z)=1, \quad \phi_i(z)=\frac{\sqrt{1-a^2}}{z-a} \left(\frac{1-az}{z-a}\right)^{i-2} \quad   i=2,3,\ldots,n+1 \quad \mbox{(for discrete-time systems)}
\end{equation}
where $n$ is the order of the controller, $\xi>0$, and $-1<a<1$.

\textcolor{magenta}{\textbf{Generalized orthonormal basis functions:}}

\begin{equation}
\phi_1(s)=1, \quad \phi_i(s)=\frac{\sqrt{2Re(\xi_{i-1})}}{s+\xi_{i-1}} \prod_{k=1}^{i-2}\frac{s-\bar{\xi_k}}{s+\xi_k} \quad  i=2,3,\ldots,n+1 \quad \mbox{(for continuous systems)}
\end{equation}
or:
\begin{equation}
\phi_1(z)=1, \quad \phi_i(z)=\frac{\sqrt{1-|\xi_{i-1}|^2}}{z-\xi_{i-1}} \prod_{k=1}^{i-2}\frac{1-\bar{\xi_k}z}{z-\xi_k} \quad  i=2,3,\ldots,n+1 \quad \mbox{(for discrete-time systems)}
\end{equation}
where $\xi_1, \ldots, \xi_n$ are complex numbers, $Re$ denotes the real part of a complex number, and $\bar{\xi_k}$ is the complex conjugate of $\xi_k$.

As stated earlier, one can define one's own vector of basis functions, $\phi$, of any desired order as well as the above listed types.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{fig1}
\caption{GPC specifications converted to linear constraints in Nyquist diagram}
\label{fig:GPC}
\end{figure}

\subsection{GPC controller}
Gain margin, phase margin and crossover frequency (GPC) are typical performance specifications for PID controller design in industry. We use these specifications for SISO minimum-phase stable systems if the number of integrators in the open-loop transfer function is less than or equal to 2. Specifying the gain and phase margin defines a straight line in the Nyquist diagram (see $d_1$ in Fig. \ref{fig:GPC}). Now, if the Nyquist curve of the open loop system lies in the right side of $d_1$ the desired values for the gain margin $g_m$ and phase margin $\phi_m$ will be assured. This can be represented by a set of linear constraints thanks to the linear parameterization of the controller. Now, consider another straight line $d_2$ which is tangent to the unit circle in the sector created by $d_1$ and the imaginary axis. If we call $\omega_x$ the frequency at which the Nyquist curve intersects $d_2$, a crossover frequency greater than or equal to $\omega_x$ can be achieved by satisfying a set of linear constraints. In fact, for frequencies greater than $\omega_x$ the Nyquist curve should lie below $d_1$ and above $d_2$ while for frequencies less than $\omega_x$ it should lie below $d_2$.

Let us define the set of all points in the complex plane on the line $d$ by $f(x+iy, d) = 0$. Assume that $f(x+iy, d) < 0$ represents the half plane that excludes the critical point. Then, to find optimal controller parameters, an optimization problem like the following would be reached:

 \[
\max_\rho{g}
\]
subject to:
\begin{align}
\label{eq:opGPC}
& f(\rho^T \phi(j\omega_{ik})G_i(j\omega_{ik}),d_1)<0 \quad \mbox{for} \quad \omega_{ik}>\omega_x, \nonumber \\
& f(\rho^T \phi(j\omega_{ik})G_i(j\omega_{ik}),d_2)>0 \quad \mbox{for} \quad \omega_{ik}>\omega_x,  \\
& f(\rho^T \phi(j\omega_{ik})G_i(j\omega_{ik}),d_2)<0 \quad \mbox{for} \quad \omega_{ik} \leqslant \omega_x, \nonumber \\
& \mbox{for} \quad k=1,\ldots,N_i \:\: \mbox{and} \:\: i=1,\ldots,m. \nonumber
\end{align}
where, the objective function for minimization, $g$, can be one of the two following cases:
\begin{itemize}
\item When one wants the open-loop of the system to be close to a desired open-loop, $L_d$. In this case, $g$ would be the quadratic criterion below:
\begin{equation}
g=\sum_{i=1}^{m}\sum_{k=1}^{N_i} |L_i(j\omega_{ik},\rho)-L_d(j\omega_{ik})|^2
\label{eq:quadratic criterion}
\end{equation}
where $L_i(j\omega_{ik})=\rho^T \phi(j\omega_{ik})G_i(j\omega_{ik})$.

\item When the control objective is to optimize the load disturbance rejection of the closed-loop. This is, in general, achieved by maximizing the controller gain at low frequencies. For example, for a PID controller it corresponds to maximizing the coefficient of the integral part, i.e. $g = k_i$.
\end{itemize}

It should be noted that for all controller types including self-defined ones, one can specify an $L_d$ to minimize the criterion (\ref{eq:quadratic criterion}). But, optimizing load disturbance rejection is considered only in PID, PI, PD, and Laguerre controllers.

In many control problems a constraint on the controller gain at high frequencies can help reducing the large pick values of the control input. This can be achieved by considering a bound on the real and the imaginary part of the controller, $\rho^T\phi(j\omega_{ik})$, at frequencies greater than $\omega_h$:
\begin{align}
& -K_u<Re(\rho^T \phi(j\omega_{ik}))<K_u \quad \mbox{for} \quad \omega_{ik} > \omega_h \nonumber \\
& -K_u<Im(\rho^T \phi(j\omega_{ik}))<K_u \quad \mbox{for} \quad \omega_{ik} > \omega_h 
\label{eq:Kuwh}
\end{align} 
where $Re$ and $Im$ denote, respectively, real and imaginary parts of a complex value. These linear constraints will be included in the optimization problem (\ref{eq:opGPC}) if specified by user.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{fig2}
\caption{Loop shaping in Nyquist diagram by quadratic programming}
\label{fig:LS}
\end{figure}

\subsection{Loop shaping controller}
The performance specification can be defined by a desired open loop transfer function (or nonparametric frequency response data), $L_d(j\omega)$. It can be computed if a desired reference model $M$ is available: $L_d=M/1-M$. Typically for stable systems $L_d(s)=\omega_c/s$ would work well. Then a controller can be designed by minimizing the quadratic criterion of (\ref{eq:quadratic criterion}).

The modulus margin, the shortest distance between the Nyquist curve and the critical point, which is a better robustness indicator than the classical gain and phase margins, is considered in the loop shaping controller design method. For example, a modulus margin $M_m$ of $0.5$ is met if the Nyquist curve does not intersect a circle of radius $0.5$ centered at the critical point. This can be achieved if the Nyquist diagram is at the side of $d$, a straight line tangent to the modulus margin circle, that excludes the critical point. This constraint is linear but conservative. The conservatism can be reduced if the slop of this line changes with frequency. A good choice is a line $d(M_m,L_d(j\omega_k))$ orthogonal to the line that connects the critical point and $L_d(j\omega_k)$ and tangent to the modulus margin circle (see Fig. \ref{fig:LS}). Thus the controller is designed solving the following quadratic optimization problem:
\[
\min_\rho{\sum_{i=1}^{m}\sum_{k=1}^{N_i} |L_i(j\omega_{ik},\rho)-L_d(j\omega_{ik})|^2}
\]
subject to:
\begin{align}
\label{eq:opLS}
& f(\rho^T \phi(j\omega_{ik})G_i(j\omega_{ik}),d(M_m,L_d(j\omega_{ik})))<0 \\
& \mbox{for} \quad  k=1,\ldots,N_i \:\: \mbox{and} \:\: i=1,\ldots,m. \nonumber
\end{align}
This approach can be applied to unstable systems if $L_d$ contains the same number of unstable poles as well as the poles  on the imaginary axis of $L_i(s)$ (see \cite{KG10} for details).

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{fig3}
\caption{Expression of the robust performance condition as linear constraints}
\label{fig:Hinf}
\end{figure}

\subsection{$H_\infty$ controller}
Consider an SISO plant model with multiplicative unstructured uncertainty: $\tilde{G}(j\omega)=G(j\omega)[1+W_2(j\omega)\Delta]$ where $G(j\omega)$ is the plant nominal frequency function, $W_2(j\omega)$ is the uncertainty weighting frequency function, and $\Delta$ is a stable transfer function with $\|\Delta\|_\infty < 1$. In the Nyquist diagram the open loop frequency function will belong to a disk centered at $L(j\omega,\rho)$ with a radius of $|W_2(j\omega)L(j\omega,\rho)|$. This disk can be approximated by a circumscribed polygon with $X > 2$ vertices, such that $L_x(j\omega,\rho)=K(j\omega,\rho)G_x(j\omega)$ for $x=1,\ldots,X$, where
\begin{equation}
G_x(j\omega)=G(j\omega)\left[ 1+\frac{|W_2(j\omega)|}{\cos{(\pi/X)}} e^{j2\pi x/X} \right]
\end{equation}

Suppose that the nominal performance is defined as $\|W_1S\|_\infty<1$, where $S=(1+KG)^{-1}$ is the sensitivity function and $W_1$ is the performance weighting filter. This condition is satisfied if the Nyquist curve of the nominal model does not intersect the performance disk, a disk centered at the critical point with a radius of $|W_1(j\omega)|$. Therefore, the robust performance is achieved if there is no intersection between the uncertainty and performance disks \cite{DFT92} (see Fig. \ref{fig:Hinf}). This constraint can be linearized using a straight line $d(W_1(j\omega),L_d(j\omega))$ which is tangent to the performance disk and orthogonal to the line connecting the critical point and $L_d(j\omega)$ \cite{KG10}. The robust performance is met if $L_x(j\omega,\rho)$ is at the side of $d(W_1(j\omega),L_d(j\omega))$ that excludes the critical point for all $\omega$. This can be represented by the following set of linear constraints:
\begin{align}
\label{eq:rbstper}
& f(\rho^T \phi(j\omega_{k})G_x(j\omega_{k}),d(W_1(j\omega_k),L_d(j\omega_k)))<0 \\ 
& \mbox{for} \quad k=1,\ldots,N \quad \mbox{and} \quad x=1,\ldots,X. \nonumber
\end{align}
 
Then, in (\ref{eq:rbstper}), if we let $W_2=0$, it will be equivalent to the nominal performance condition: 
\begin{equation}
\label{eq:nomper}
\|W_1S\|_\infty<1
\end{equation}
and if we let $W_1=0$, the robust stability condition:
\begin{equation}
\label{eq:rbststab}
\|W_2T\|_\infty<1
\end{equation}
 will be obtained where $T$ is the complementary sensitivity function. Other than these two constraints, constraints on the weighted infinity norm of other closed loop sensitivity functions, after being linearized in a similar manner, can also be included in the optimization problem (see more details in \cite{KG10}):
\begin{equation}
\label{eq:W3W4}
\|W_3KS\|_\infty<1 \quad \mbox{and} \quad \|W_4GS\|_\infty<1 
\end{equation}
where $W_3$ and $W_4$ are corresponding weighting filters.

As a result, three different optimization problems are considered in $H_\infty$ controller design method:
\begin{itemize} 
\item Defining a desired open-loop $L_d$ and minimizing the criterion (\ref{eq:quadratic criterion}) in the following optimization problem:
\[
\min_\rho{\sum_{i=1}^{m}\sum_{k=1}^{N_i} |L_i(j\omega_{ik},\rho)-L_d(j\omega_{ik})|^2}
\]
subject to:
\begin{align}
\label{eq:opHinf1}
 \|W_1S\|_\infty&<\lambda_1 \nonumber \\
 \|W_2T\|_\infty&<\lambda_2  \\
 \|W_3KS\|_\infty&<\lambda_3 \nonumber \\
 \|W_4GS\|_\infty&<\lambda_4 \nonumber
\end{align}
where $\lambda=[\lambda_1, \: \lambda_2, \: \lambda_3, \: \lambda_4]$ is a vector of positive coefficients determining the importance of each constraint. The user chooses $\lambda_1,\ldots,\lambda_4$. Setting one of them $0$ means that the corresponding constraint should be omitted. Also, as stated before, all these constraints are used in their linearized form and the second constraint is converted to $y$ (the number of the polygon's vertices) constraints.
\item Solving the following feasibility problem:
\[
\min{\gamma}
\]
subject to:
\begin{align}
\label{eq:opHinf2}
 \|W_1S\|_\infty &<\lambda_1\gamma \nonumber \\
 \|W_2T\|_\infty &<\lambda_2\gamma  \\
 \|W_3KS\|_\infty &<\lambda_3\gamma \nonumber \\
 \|W_4GS\|_\infty &<\lambda_4\gamma \nonumber 
\end{align}
where $\gamma$ is minimized by a bisection algorithm to reach the best performance possible in terms of the above constraints. The user must assign a nonzero value to at least one of the coefficients $\lambda_1$, $\lambda_2$, $\lambda_3$, and $\lambda_4$.
\item Considering only the commonly-used robust performance constraint:
 \begin{equation}
\label{eq:justrbstper}
 \|W_1S+W_2T\|_\infty<\gamma
\end{equation}
where, the linearized form of this constraint, i.e. Eq. (\ref{eq:rbstper}), will in fact be used. In this case, if the user defines an $L_d$, the criterion (\ref{eq:quadratic criterion}) will be minimized while setting $\gamma=1$. Otherwise a feasibility problem will be solved by minimizing $\gamma$ by a bisection algorithm.
\end{itemize}

\subsection{MIMO controller}
The performance specifications for SISO systems can also be used for designing MIMO controllers if the open loop system is decoupled. The main idea is to design a MIMO decoupling controller such that the open-loop transfer matrix $L(j\omega)$ becomes diagonally dominant. For this reason a diagonal desired open loop transfer matrix $\textbf{L}_d$ is considered and the following quadratic criterion is minimized:
\begin{equation}
\label{eq:L-LD}
J(\rho)=\sum_{i=1}^{m}\sum_{k=1}^{N_i} \| \textbf{L}_i(j\omega_{ik},\rho)- \textbf{L}_d(j\omega_{ik}) \|_F
\end{equation}
where $F$ stands for the Frobenius norm.

MIMO controllers presented by a matrix of transfer functions are considered where each element $K_{ij}$ of the matrix should be linearly parameterized, i.e., $K_{ij}=\rho_{ij}^T\phi_{ij}$. The controller parameters are obtained by minimizing $J(\rho)$ under some constraints to meet the SISO specifications for each diagonal element. 

In MIMO systems, besides the performance constraints, there are other constraints implying the stability of MIMO systems that should be considered. In fact, because the closed-loop system will not be completely diagonal, the stability of dominant loops will not guarantee the stability of the MIMO system. However, a stability condition can be obtained based on Gershgorin bands (see \cite{GKL10b}):
\begin{align}
\label{eq:Gersh}
& r_q(\omega_k,\rho)\big| [1+L_{dq}(j\omega_k)]\big|-Re\big([1+L_{dq}(-j\omega_k)][1+L_{qq}(j\omega_k,\rho)]\big)<0 \nonumber \\
& \mbox{for} \quad q=1,\ldots,n_o \quad  \mbox{and} \quad k=1,\ldots,N 
\end{align}
where
\[
r_q(\omega,\rho)=\sum_{p=1,p\neq q}^{n_o} |L_{pq}(j\omega,\rho)|,
\]
$n_o$ is the number of the outputs of the system, and $L_{dq}$ is the $q^{th}$ diagonal element of $L_d$. This constraint is written for one model. It will be considered for all models when tackling multi-model systems.

In summary, in MIMO systems, since the method is based on decoupling, always the criterion (\ref{eq:L-LD}) is minimized. Hence, for every diagonal element of the open loop matrix ($\textbf{L}=\textbf{GK}$), an $L_d$ should be specified. ($\textbf{L}_d$ is a diagonal matrix with these $L_d$'s as its diagonal elements.) Also all the previously explained performance conditions(GPC, loop shaping, and $H_\infty$) will be applied on the diagonal elements of the open loop transfer matrix. The stability conditions of (\ref{eq:Gersh}) will be added to the other performance costraints. 

\subsection{Gain-scheduled controller}

All presented robust controller design methods for systems with multimodel uncertainty can be extended to designing
gain-scheduled controllers. Suppose that each model $G_i$ is associated to a value of a scheduling parameter vector $\theta$, which is measured in real time. The controller parameters can be polynomial functions of $\theta$ and be computed by the optimization algorithm. Then, in all the previous constraints, we would place:

\[
\rho=M\bar{\theta}_l
\]
where
\begin{align}
\label{eq:GS}
& M=\left[ \begin{array}{cccc}
(\rho_{1,n_p})^T & \cdots & (\rho_{1,1})^T & (\rho_{1,0})^T \\ [.25 cm]
 \vdots & \ddots & \vdots & \vdots \\ [.25 cm]
(\rho_{n_\rho,n_p})^T & \cdots & (\rho_{n_\rho,1})^T & (\rho_{n_\rho,0})^T \end{array} \right] \\
& \mbox{and} \quad \bar{\theta}_l=[\theta_l^{n_p}\:  \ldots \: \theta_l \: \overrightarrow{1}]^T. \nonumber 
\end{align}
where $n_p$ is the order of polynomials describing controller parameters and $n_\rho$ is the dimension of $\rho$ which is the same as the dimension of the vector of the basis functions $\phi$.

For instance, for a PID controller ($n_\rho=3$) with a scalar scheduling parameter and the vector $\rho$ as a second order polynomial of $\theta$ ($n_p=2$) we will have a parametrization like this:
\begin{equation}
\label{eq:GSPID}
\rho(\theta)=\left[ \begin{array}{ccc}
k_{p_2} & k_{p_1} & k_{p_0} \\ [.25 cm]
k_{i_2} & k_{i_1} & k_{i_0} \\ [.25 cm]
k_{d_2} & k_{d_1} & k_{d_0} \end{array} \right] \: \left[ \begin{array}{c}
\theta^2 \\ [.25 cm]
 \theta \\ [.25 cm]
1 \end{array} \right] 
\end{equation}
For more details about the gain-scheduled controller design see \cite{KKL07e}.

\section{Toolbox commands}
The procedure of design comprises 3 steps. First the type (or structure) of the controller should be determined. Then the desired performance characteristics are specified, and finally a controller with these desired type and performance is designed. In the following comes a description of these three steps with corresponding commands.

\subsection{Determining controller structure}
The first step of design is determining the desired controller type. By defining the controller type in fact the vector of basis transfer functions $\phi$ is specified. In the following command: 
\begin{lstlisting}
phi = conphi (ConType , ConPar , CorD , F) 
\end{lstlisting}
\begin{table}
\centering
\caption{Available controller structures and the corresponding parameters to be defined by user} \smallskip
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\begin{tabularx}{0.8\textwidth}{ l  R  c }
\hline \hline \noalign{\smallskip}
 ConType  & \multicolumn{2}{c}{ConPar} \\  [.3 cm] \hline \hline \noalign{\smallskip}
  \multirow{2}{*}{'PID'} & Continuous & \texttt{$\tau$} \\ 
  & Discrete & \texttt{[Ts, $\tau$]} \\ [.3 cm] \hline \noalign{\smallskip}
  \multirow{2}{*}{'PI'} & Continuous & \texttt{[]}  \\
  & Discrete & \texttt{Ts} \\ [.3 cm] \hline \noalign{\smallskip}
  \multirow{2}{*}{'PD'} & Continuous & \texttt{$\tau$} \\
  & Discrete & \texttt{[Ts, $\tau$]}  \\ [.3 cm] \hline \noalign{\smallskip}
  \multirow{2}{*}{'Laguerre'} & Continuous & \texttt{[$\xi$, n]} \\
  & Discrete & \texttt{[Ts, a, n]}  \\ [.3 cm] \hline \noalign{\smallskip}
  \multirow{2}{*}{'generalized'} & Continuous & \texttt{[$\xi_1$, $\xi_2$, $\ldots$, $\xi_n$]} \\
  & Discrete & \texttt{[Ts, $\xi_1$, $\xi_2$, $\ldots$, $\xi_n$]}  \\ [.3 cm] \hline
\hline
\end{tabularx}
\label{tab:first command}
\end{table}
are the controller type and subsequently the vector $\phi$ specified by the user. 

\textcolor{magenta}{\texttt{ConType}} is a string representing the desired controller type. It is not case sensitive when being defined.

\textcolor{magenta}{\texttt{ConPar}}, depending on the the specified controller type \verb"ConType", can be a scalar or a vector containing the  parameters of that type. Table \ref{tab:first command} shows available controller types and corresponding parameters. As it can be seen in this table, when designing a discrete controller, \verb"Ts" (sampling period) is always the first parameter in \verb"ConPar". Let \texttt{Ts=-1} if you want to leave it unspecified. The rest of the parameters are the same in most of the situations for discrete and continuous controllers. See section 2 (Background theory) for details about these parameters.

\textcolor{magenta}{\texttt{CorD}} is either \texttt{'s'} or \texttt{'z'} showing, respectively, that the controller is continuous or discrete. If not mentioned, the continuous case will be considered. 

\textcolor{magenta}{\texttt{F}} is a transfer function by which a vector $\phi$ can be multiplied. For example one can multiply a factor of integral $\frac{1}{s}$ to PID basis functions to get: $\phi=\frac{1}{s} \times [1\:\: \frac{1}{s} \:\: \frac{s}{1+\tau s}]^T$. 

\textcolor{magenta}{\texttt{phi}} is a structure containing the vector $\phi$ and the controller type. If you'd like to define other basis functions which is not available, i.e. your customized vector of $\phi$, type : \texttt{phi.phi = your vector in a column form} (see Example 5 below).

\textcolor{blue}{\emph{Example 1}}: A continuous PID controller with $\tau=0.1$:

\begin{lstlisting}
phi = conphi ('PID' , 0.1) 

phi = 

        phi: [3x1 tf]
    ConType: 'PID'

phi.phi
 
Transfer function from input to output...
 #1:  1
 
      1
 #2:  -
      s
 
          s
 #3:  ---------
      0.1 s + 1      
\end{lstlisting}

\textcolor{blue}{\emph{Example 2}}: A discrete PI controller with sampling time of 0.05 seconds:

\begin{lstlisting}
phi = conphi ('PI' , 0.05 , 'z') 

phi = 

        phi: [2x1 tf]
    ConType: 'PId'

phi.phi
 
Transfer function from input to output...
 #1:  1
 
        z
 #2:  -----
      z - 1
 
Sampling time: 0.05
\end{lstlisting}
The lowercase letter d in \texttt{ConType} shows that it is a discrete PI controller.

\textcolor{blue}{\emph{Example 3}}: A continuous PID controller with $\tau=0.1$ multiplied by an integrator:

\begin{lstlisting}
s=tf('s');  F=1/s;
phi = conphi ('PID' , 0.1 , 's' , F) 

phi = 

        phi: [3x1 tf]
    ConType: 'FtimesPID'
    
phi.phi
 
Transfer function from input to output...
      1
 #1:  -
      s
 
       1
 #2:  ---
      s^2
 
           s
 #3:  -----------
      0.1 s^2 + s    

\end{lstlisting}

\textcolor{blue}{\emph{Example 4}}: A continuous 3rd order Laguerre controller with $\xi=1$:

\begin{lstlisting}
phi = conphi ('Laguerre',[1,3])

phi = 

        phi: [4x1 tf]
    ConType: 'Laguerre'
        par: [1 3]
phi.phi
 
Transfer function from input to output...
 #1:  1
 
      1.414
 #2:  -----
      s + 1
 
      1.414 s - 1.414
 #3:  ---------------
       s^2 + 2 s + 1
 
      1.414 s^2 - 2.828 s + 1.414
 #4:  ---------------------------
         s^3 + 3 s^2 + 3 s + 1
         
\end{lstlisting}
The third field of \verb"phi" contains the values of $\xi$ and $n$ of the Laguerre controller.

\textcolor{blue}{\emph{Example 5}}: A continuous, customized vector of basis functions:

\begin{lstlisting}
s = tf ('s');
phi.phi = [1 ; 1/s ; s/(s^2+2*s+1)];

 phi.phi
 
Transfer function from input to output...
 #1:  1
 
      1
 #2:  -
      s
 
            s
 #3:  -------------
      s^2 + 2 s + 1
\end{lstlisting}

After defining our desired controller structure, we shall proceed to the next step: specifying performance characteristics.

\subsection{Determining system performance}
The desired performance attributes of the system are determined by the following command:
\begin{lstlisting}
per = conper (PerType , par , Ld) 
\end{lstlisting}
\begin{table}
  \centering 
  \caption{The parameters corresponding to each type of performance} \smallskip \smallskip
  \begin{tabularx}{0.8\textwidth}{X X}
\hline \hline \noalign{\smallskip} \noalign{\smallskip} 
  \texttt{PerType} & \texttt{par}  \\ [0.3 cm] \hline \hline \noalign{\smallskip} \noalign{\smallskip} \noalign{\smallskip} 
   \texttt{'GPC'}& \texttt{[gm , pm , wc , Ku , wh]}  \\ [.5 cm]
   \texttt{'LS'}& \texttt{[Mm , Ku , wh]}  \\ [0.5 cm]
   \multirow{5}{*}{\texttt{'Hinf'}} & \texttt{par.W1} \\
   & \texttt{par.W2}\\
   & \texttt{par.W3}\\
   & \texttt{par.W4}\\
   & \texttt{par.lambda} \\ [.3 cm]
\hline \hline
\end{tabularx}
  \label{tab:second command}
\end{table}
\textcolor{magenta}{\texttt{PerType}} is a string specifying the desired performance of the system. It can be \texttt{'GPC'}, \texttt{'LS'} or \texttt{'Hinf'}. 

\textcolor{magenta}{\texttt{Ld}} is a desired open loop which can be a parametric transfer function or a nonparametric \texttt{idfrd} object containing frequency response data over a frequency vector. 

\textcolor{magenta}{\texttt{per}} is a structure that contains all the data specified by the user in this command.

\subsubsection{\texttt{'GPC'}} 
\texttt{'GPC'} stands for the case when one wants to determine minimum values for gain margin, phase margin, and crossover frequency. As shown in the Table \ref{tab:second command}, \texttt{par} in this case is a vector containing the values of gain margin $g_m$, phase margin $p_m$, crossover frequency $\omega_c$, and an upper bound for the controller gain $K_u$ which may be applied at frequencies higher than $\omega_h$. 

For a more satisfactory result, the user had better specify a crossover frequency. Otherwise a default value of $\omega_{max}/20$ would be assigned to it. 

$K_u$ and $\omega_h$ are optional. If they are not assigned, no upper bound for the controller gain is considered.

If \texttt{Ld} is specified, the quadratic criterion (\ref{eq:quadratic criterion}) will be minimized; otherwise, the controller gain at low frequencies will be maximized. It should, however, be noted that maximizing controller gain at low frequencies will be done in PID, PI, PD, and Laguerre controllers. In \texttt{'generalized'} type and in other self-defined basis functions, you should specify an \texttt{Ld}.

\subsubsection{\texttt{'LS'}} 
\texttt{'LS'} stands for Loop Shaping controller. In this case, \texttt{par} is a vector containing modulus margin $M_m$, and (if applicable) $K_u$ and $\omega_h$. In loop shaping, the objective is to force open loop to act like a desired open loop function. So a desired open loop function ($L_d$) should always be specified by the user.

\subsubsection{\texttt{'Hinf'}} 
To use $H_\infty$ controller design method, type \texttt{'Hinf'} as \texttt{PerType}. Here, \texttt{par} is a structure whose fields are \texttt{$W_1$}, \texttt{$W_2$}, \texttt{$W_3$}, \texttt{$W_4$}, and \texttt{lambda}. \texttt{$W_1$}, \texttt{$W_2$}, \texttt{$W_3$}, and \texttt{$W_4$} are four weighting filters which can be parametric (continuous or discrete transfer functions) or nonparametric (a vector of complex values in discrete frequencies defined in form of an \texttt{idfrd} object). The user selects which one of them to consider depending on his/her problem. \texttt{par.lambda} is a vector with four elements ($\lambda_1$, $\lambda_2$, $\lambda_3$, and $\lambda_4$) described in section 2 (Background theory). If one element is zero, the constraints related to the corresponding weighting filter will not be considered in the optimization problem (\ref{eq:opHinf1} or \ref{eq:opHinf2}). By assigning different values for these for elements, the user can emphasize on each one of them s/he desires. Let $\lambda_1=\lambda_2=\lambda_3=\lambda_4=0$ to use optimization problem (\ref{eq:justrbstper}) which considers only the common robust performance constraint.

To see some examples, look at Section 4.

\subsection{Controller Design}
After gathering the required data from user, the controller is designed by the following command:

\begin{lstlisting}  
K = condes (G , phi , per , options)
\end{lstlisting}
\textcolor{magenta}{\texttt{G}} is a cell, i. e., \texttt{G\{1\}}, \texttt{G\{2\}}, \dots, \texttt{G\{m\}} represent models $G_1$, $G_2$, $\ldots$, $G_m$. In case there is just one model, define it as \texttt{G\{1\}} or simply \texttt{G}. 

Parametric models should be defined as a \texttt{tf} object. If your model is not \texttt{tf}, for example it is an \texttt{ss} object, convert it to a \texttt{tf} object using the command \texttt{tf}. Type \texttt{doc tf} for details.

Nonparametric models should be defined as an \texttt{idfrd} object. If your model is the output of the identification toolbox of Matlab, it is an \texttt{idfrd} object. If your nonparametric model is not an \texttt{idfrd} object, type \texttt{doc idfrd} to see details about creating or converting your model to an \texttt{idfrd} object.

\textcolor{blue}{\textbf{SISO systems}}

\textcolor{magenta}{\texttt{phi}} is the output of the first command. The command \texttt{condes} designes a controller of the specified type to meet the performance criteria implied by \texttt{per}.

\textcolor{magenta}{\texttt{per}} is a cell. \texttt{per\{1\}}, \texttt{per\{2\}}, \dots, \texttt{per\{m\}} contain the desired performance characteristics of, respectively, \texttt{G\{1\}}, \texttt{G\{2\}}, \dots, \texttt{G\{m\}}. When you want to apply one performance criteria for all models, simply just enter \texttt{per}, (you don't need to define a cell).

When determining an \texttt{Ld} in \texttt{per}, (which is compulsory in \texttt{'LS'} case but optional in \texttt{'GPC'} and \texttt{'Hinf'} cases) the objective of design will be minimizing the difference between the system open loop and the desired open loop \texttt{Ld} which is a quadratic objective function in terms of controller parameters $\rho$. The constraints in all of the three cases are linear in terms of $\rho$ (optimization problems \ref{eq:opGPC},\ref{eq:opLS},\ref{eq:opHinf1}). Hence we have a quadratic programming problem which is solved by the solver \texttt{quadprog}.

In \texttt{'GPC'} and \texttt{'Hinf'} cases, however, one can leave \texttt{Ld} unspecified intending to solve one of the optimization problems (\ref{eq:opGPC}, \ref{eq:opHinf2}, or \ref{eq:justrbstper}). The objective function and the constraints of these optimization problems are linear in terms of $\rho$. Then the solver \texttt{linprog} would be used to find optimal controller.

\textcolor{blue}{\textbf{MIMO systems}}

\textcolor{magenta}{\texttt{phi}} is an $n_i \times n_o$ cell where $n_i$ is the number of inputs and $n_o$ is the number of outputs of the system. For example \texttt{phi\{p,q\}} is the vector of basis functions ($\phi$) for the element of row \texttt{p} and column \texttt{q} of the controller matrix $K$. So each element of the controller matrix can have a different vector of $\phi$, or different structure. They should be defined separately by the first command, for example in a loop. Should you specify one controller type or structure for all the elements of the controller matrix, just simply enter one \texttt{phi} (not a cell) in the \texttt{condes} command. 

\textcolor{magenta}{\texttt{per}} is a cell. \texttt{per\{i\}\{q\}} ($i=1,\ldots,m$ and $q=1,\ldots,n_o$) contains the performance characteristics of the $q^{th}$ diagonal element of the open loop \texttt{L\{i\}} ($L_i=G_i \times K$), which should be defined by the second command \texttt{conper}. In MIMO systems the objective function (\ref{eq:L-LD}) will be minimized (the aim is to design a controller to decouple the system as much as possible). Hence \texttt{Ld} must be defined in \texttt{per} for every diagonal element of every open loop system. If your performance characteristics differ for the different diagonal elements of the open loop matrix, yet are the same for every model, you can simply define \texttt{per\{1\}}, \texttt{per\{2\}}, \dots, \texttt{per\{$n_o$\}} where \texttt{per\{q\}} contains the performance characteristics of the $q^{th}$ diagonal element of the open loop \texttt{L\{i\}} for $i=1,\ldots,m$. If your desired performance characteristics are the same for all the diagonal elements in all of the models, you can simply enter one \texttt{per} (not a cell) in the \texttt{condes} command to be applied to all of them.

In MIMO systems the Gershgorin stability conditions are applied on the controller design. These constraints are convex in terms of $\rho$. The \texttt{sdpt3} solver is used in all of the three performance types (\texttt{'GPC'}, \texttt{'LS'}, and \texttt{'Hinf'}). YALMIP package is used in the formulation of the problems. Hence, to design multivariable controllers you should install YALMIP and \texttt{sdpt3} solver. However, regarding the fact that these constraints are sometimes conservative in an unnecessary manner, one can skip applying them (see options section below). In this case, the standard solver \texttt{quadprog} will be used for solving the resulting quadratic optimization problem.

\textcolor{blue}{\textbf{options}}

\texttt{options} is a structure whose fields can be set by this command:

\begin{lstlisting}
options = condesopt ('param1' , value1 , 'param2' , value2, ... )
\end{lstlisting}
\begin{table}
  \centering 
  \caption{Toolbox options} \smallskip \smallskip
  \newcolumntype{L}{>{\raggedright\arraybackslash}X}
  \begin{tabularx}{0.8\textwidth}{l l L}
\hline \hline \noalign{\smallskip} \noalign{\smallskip} 
  Option & Default value & Description  \\ [0.3 cm] \hline \hline \noalign{\smallskip} \noalign{\smallskip} \noalign{\smallskip} 
   \texttt{w} & \texttt{[]} & \texttt{w} is a cell. \texttt{w\{i\}} is the vector of frequencies over which $G_i(j\omega)$ is known.\\ [.3 cm]
   \texttt{MIMOstability}& \texttt{true} & Shows that Gershgorin stability conditions for the MIMO system will be applied. Set it to logical 0 (false) to prevent applying them. \\ [0.3 cm]
   \texttt{beta} & \texttt{20} & The angle of line $d_2$ with the real axis in degrees \\ [0.3 cm]
   \texttt{np} & \texttt{[]} & The degree of polynomials describing the gain-scheduled controller parameters \\ [.3 cm]
   \texttt{GSpar} & \texttt{[]} & A vector (or matrix if we have more than one scheduling parameter) of the scheduling parameter values in designing a gain-scheduled controller\\
   Other solver options & \texttt{[]} & All available options for the solver in use.\\[.3 cm]  
\hline \hline
\end{tabularx}
  \label{tab:condesoptions}
\end{table}
Table \ref{tab:condesoptions} shows available options.

\textcolor{magenta}{\texttt{w:}} In nonparametric models where the class of models are \texttt{idfrd}, every model has its own vector of frequency points and you do not need to assign frequency vectors in options. The default value of \texttt{options.w} is then \texttt{[]}. 

If you want to specify a frequency grid for each parametric model, define \texttt{w} as a cell such that \texttt{w\{i\}} is the vector of frequency points in which the frequency response $G_i(j\omega)$ is obtained. In other words, after you type:
\begin{lstlisting}
options = condesopt ('w' , w)
\end{lstlisting}
\texttt{options.w} will be a cell with \texttt{options.w\{1\}}, \texttt{options.w\{2\}}, \dots. Should you use just one frequency vector for all models, simply define \texttt{w} as a vector (not a cell). If you do not specify \texttt{w}, a default frequency grid for each model will be created by the \texttt{bode} command. 

\textcolor{magenta}{\texttt{MIMOstability:}} \texttt{options.MIMOstability} will be logical 1 (true) or 0 (false). Its default value is true meaning that the Gershgorin stability conditions are considered in the design problem in MIMO systems. If you'd like to omit these conditions you should set this option to logical 0 (false) by typing:
\begin{lstlisting}
options = condesopt ('MIMOstability' , false)
\end{lstlisting}

\textcolor{magenta}{\texttt{beta:}} \texttt{beta} is the angle between line $d_2$ (see section 2) and the real axis. The default value of it is 20 degrees. This value is well-chosen and the final result of design is not very sensitive to small changes in it. (Recommendation: if you decide to change it, do it only after reading \cite{KKL07}.)

\textcolor{magenta}{\texttt{np:}} When you want to design a gain-scheduled controller, say for an LPV system, you should designate \texttt{np}, the order of polynomials describing the controller coefficients. The default value of it is \texttt{[]} which implies that the controller is not gain-scheduled.

\textcolor{magenta}{\texttt{GSpar:}} In designing gain-scheduled controllers, you must specify \texttt{GSpar} ($\theta$ in the theory section) as a vector of the scheduling parameter values. The number of models in \texttt{G} should be equal to the number of grid points in \texttt{GSpar}. If there are more than one scheduling parameter, \texttt{GSpar} will be a matrix. The default value of \texttt{GSpar} is \texttt{[]}.

\textcolor{magenta}{\texttt{Solver options:}} Besides, the options mentioned above, one can alter every option available for different solvers. In this case, one should be aware of which solver would be used in which optimization problem. For example, if one wants to design a PID controller for an SISO system without specifying a desired open loop (where optimization problem (\ref{eq:opGPC}) is solved by \texttt{linprog}), one can change every option available for the solver \texttt{linprog} in this command. For example:
\begin{lstlisting}
options = condesopt ('w', w1, 'MaxIter', 100, 'Display', 'iter')
\end{lstlisting}
changes the values of \texttt{MaxIter} and \texttt{Display}, which are some of \texttt{linprog}'s options, to the specified values as well as assigning \texttt{w1} to \texttt{w}.

\section{Examples}

\textcolor{blue}{\textbf{SISO systems}}

\textcolor{magenta}{\textbf{Example 1}}

\emph{Model:} $G=\frac{e^{-s}}{(s+1)^3}$

\emph{Frequency:} N=100 logarithmically spaced points in interval: $[0.08/100,0.08\times100]$

\emph{Controller:} A PID controller with $\tau=0.14$

\emph{Objective:} Gain margin = 2, Phase margin = $60^{\circ}$, Crossover frequency = 0.08 rad/s 

\begin{lstlisting}
s=tf('s');
G=exp(-s)/(s+1)^3;
w=(logspace(log10(.08/100),log10(.08*100),100))';

phi=conphi('PID',.14);
per=conper('GPC',[2,60,.08]);

options = condesopt ('w',w);
K=condes(G,phi,per,options)
\end{lstlisting}

\emph{Resulting controller:}

\begin{lstlisting}
Transfer function:
1.863 s^2 + 0.3956 s + 0.08895
------------------------------
         0.14 s^2 + s
\end{lstlisting}

\textcolor{magenta}{\textbf{Example 2}}

\emph{Model:} $G=\frac{e^{-5s}}{s(s+1)^3}$

\emph{Frequency:} N=80 logarithmically spaced points in interval: $[0.09/80,0.09\times80]$

\emph{Controller:} A PID controller with $\tau=0.1$

\emph{Objective:} Gain margin = 2, Phase margin = $60^{\circ}$, Crossover frequency = 0.09 rad/s, Desired open loop: $L_d(s)=0.1/s^2$ 

\begin{lstlisting}
s=tf('s');
G{1}=exp(-5*s)/(s*(s+1)^3);
w= logspace(log10(.09/80),log10(.09*80),80);

phi=conphi('PID',.1);
per=conper('GPC',[2,60,.09],.1/s^2);

options = condesopt ('w',w);
K=condes(G,phi,per,options)
\end{lstlisting}

\emph{Resulting controller:}

\begin{lstlisting}
Transfer function:
0.5613 s^2 + 0.07961 s + 0.003233
---------------------------------
           0.1 s^2 + s
\end{lstlisting}

\textcolor{magenta}{\textbf{Example 3}}

\emph{Models:} $G_1=\frac{4e^{-3s}}{(10s+1)}$, $G_2=\frac{e^{-5s}}{(s^2+14s+7.5)}$, $G_3=\frac{2e^{-s}}{(20s+1)}$

\emph{Frequency:} N=400 logarithmically spaced points in interval: $[0.001,20]$

\emph{Controller:} A PID controller with $\tau=0.05$

\emph{Objective:} Gain margin = 3 (for all models), Phase margin = $60^{\circ}$ (for all models), 
Crossover frequency: $\omega_{c_1}$=0.19 rad/s (for model 1), $\omega_{c_2}$=0.007 rad/s (for model 2), $\omega_{c_3}$=0.071 rad/s (for model 3) 

\begin{lstlisting}
s=tf('s');
G{1}=exp(-3*s)*4/(10*s+1);
G{2}=exp(-5*s)/(s^2+14*s+7.5);
G{3}=exp(-s)*2/(20*s+1);

freq = logspace(log10(.001),log10(20),400);

phi=conphi('PID',.05);

per{1}=conper('GPC',[3,60,.19]);
per{2}=conper('GPC',[3,60,.007]);
per{3}=conper('GPC',[3,60,.071]);

options = condesopt ('w',freq);
K=condes(G,phi,per,options)
\end{lstlisting}

\emph{Resulting controller:}

\begin{lstlisting}
Transfer function:
0.661 s^2 + 0.4919 s + 0.05515
------------------------------
         0.05 s^2 + s
\end{lstlisting}

\textcolor{blue}{\textbf{MIMO systems}}

\textcolor{magenta}{\textbf{Example 1}}

\emph{Model:} $ G=\left[ \begin{array}{cc}
\frac{5e^{-3s}}{4s+1}  &  \frac{2.5e^{-5s}}{15s+1} \\[.25 cm]
\frac{-4e^{-6s}}{20s+1}  &  \frac{e^{-4s}}{5s+1} 
\end{array} \right] $

\emph{Frequency:} N=500 linearly spaced points in interval: $[0.01,10]$

\emph{Controller:} A PI controller for all elements of the controller matrix (which is a $2\times2$ matrix)

\emph{Objective:} Obtaining a multivariable controller by loop-shaping method applying only MIMO stability conditions (Modulus margin = 0, $L_d(s)=1/(30s)$ for all diagonal elements of the open loop matrix).

\begin{lstlisting}
s=tf('s');
G{1}=[5*exp(-3*s)/(4*s+1) 2.5*exp(-5*s)/(15*s+1); ...
    -4*exp(-6*s)/(20*s+1) exp(-4*s)/(5*s+1)];

freq= linspace(.01,10,500);

phi=conphi('PI'); % or : phi=conphi('PI',[],'s')

performance=conper('LS',0,1/(30*s)); 

options = condesopt ('w',freq);
K=condes(G,phi,performance,options)
\end{lstlisting}

\emph{Resulting controller:}

\begin{lstlisting}
Transfer function from input 1 to output...
      0.01063 s + 0.002391
 #1:  --------------------
               s
 
      0.01916 s + 0.007955
 #2:  --------------------
               s
 
Transfer function from input 2 to output...
      0.0007281 s - 0.005089
 #1:  ----------------------
                s
 
      0.06539 s + 0.01074
 #2:  -------------------
               s
\end{lstlisting}





\bibliographystyle{plain}
\bibliography{bibliog}
\end{document}